<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>念君的个人站点</title>
  <subtitle>生命的意义，不在于追求什么，而在于我们是不是永远在追求的路上。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.liminwu.me/"/>
  <updated>2017-06-10T06:35:30.000Z</updated>
  <id>http://www.liminwu.me/</id>
  
  <author>
    <name>limin wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://www.liminwu.me/post/Android%20%E8%AF%BBExcel%E6%96%87%E4%BB%B6.html"/>
    <id>http://www.liminwu.me/post/Android 读Excel文件.html</id>
    <published>2017-06-10T06:26:50.000Z</published>
    <updated>2017-06-10T06:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-读写-Excel-文件"><a href="#Android-读写-Excel-文件" class="headerlink" title="Android 读写 Excel 文件"></a>Android 读写 Excel 文件</h1><blockquote>
<p>需求背景：最近在做项目过程中，需要读取 Excel 文件，Excel文件可以来自用户插在Android设备上的外接U盘，也可以是保存在项目Assets、 Raw里面。<br>资料参考：查阅了很多相关资料，读取外接U盘主要用到了Android 读取USB文件的第三方开源库<br>[GitHub]（<a href="https://github.com/magnusja/libaums）" target="_blank" rel="external">https://github.com/magnusja/libaums）</a><br>用到的Jar文件 <a href="http://download.csdn.net/detail/liminwu_6/9866577" target="_blank" rel="external">Jar</a><br>读写Asset Raw文件也可以用<a href="http://download.csdn.net/detail/likai22/534250" target="_blank" rel="external">jxl.jar</a><br>本文将从以下两个方面介绍Excel文件的读写</p>
<ul>
<li>读写外接 U 盘文件</li>
<li>读写Android 项目内Assets Raw 下的 Excel 文件<h2 id="Android-读写-U-盘-Excel-文件"><a href="#Android-读写-U-盘-Excel-文件" class="headerlink" title="Android 读写 U 盘 Excel 文件"></a>Android 读写 U 盘 Excel 文件</h2></li>
<li>首先我们需要注册广播监听外接U盘的插入和拔出<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//监听OTG插入 拔出</span></div><div class="line">   <span class="type">IntentFilter</span> usbDeviceStateFilter = <span class="function"><span class="keyword">new</span> <span class="title">IntentFilter</span>();			   <span class="title">usbDeviceStateFilter</span>.<span class="title">addAction</span>(<span class="type">UsbManager</span>.<span class="type">ACTION_USB_DEVICE_ATTACHED</span>);</span></div><div class="line">   <span class="title">usbDeviceStateFilter</span>.<span class="title">addAction</span>(<span class="type">UsbManager</span>.<span class="type">ACTION_USB_DEVICE_DETACHED</span>);</div><div class="line">   <span class="title">registerReceiver</span>(mUsbReceiver, usbDeviceStateFilter);</div><div class="line"> <span class="comment">//注册监听自定义广播</span></div><div class="line"> <span class="title">IntentFilter</span> <span class="title">filter</span> = <span class="title">new</span> <span class="title">IntentFilter</span>(<span class="type">ACTION_USB_PERMISSION</span>);</div><div class="line"><span class="title">registerReceiver</span>(mUsbReceiver, filter);</div><div class="line"> ``` </div><div class="line">* 然后重写<span class="title">onReceive</span>()方法</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>  private BroadcastReceiver mUsbReceiver = new BroadcastReceiver() {<br>        public void onReceive(Context context, Intent intent) {<br>            String action = intent.getAction();<br>            switch (action) {<br>                case ACTION_USB_PERMISSION://接受到自定义广播<br>                    UsbDevice usbDevice = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);<br>                    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {  //允许权限申请<br>                        if (usbDevice != null) {  //Do something<br>                            readDevice(getUsbMass(usbDevice));<br>                        } else {</p>
<pre><code>                    }
                } else {
                    setMsg(&quot;用户未授权，读取失败&quot;);
                }
                break;
            case UsbManager.ACTION_USB_DEVICE_ATTACHED://接收到存储设备插入广播
                UsbDevice device_add = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
                if (device_add != null) {
                    redDeviceList();
                } else {

                }
                break;
            case UsbManager.ACTION_USB_DEVICE_DETACHED://接收到存储设备拔出广播
                UsbDevice device_remove = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
                if (device_remove != null) {

                    usbFiles.clear();//清除
                    adapter.notifyDataSetChanged();//更新界面
                   cFolder = null;
                }
                break;
        }
    }
};
</code></pre><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>接收到有U盘插入之后我们要对U盘设备进行一些初始化相关的操作</div></pre></td></tr></table></figure>
<p>private void readDevice(UsbMassStorageDevice device) {<br>        // before interacting with a device you need to call init()!<br>        try {<br>            device.init();//初始化<br>//          Only uses the first partition on the device<br>            Partition partition = device.getPartitions().get(0);<br>            FileSystem currentFs = partition.getFileSystem();<br>            //fileSystem.getVolumeLabel()可以获取到设备的标识<br>            //通过FileSystem可以获取当前U盘的一些存储信息，包括剩余空间大小，容量等等<br>            // Log.d(TAG, “Capacity: “ + currentFs.getCapacity());<br>            // Log.d(TAG, “Occupied Space: “ + currentFs.getOccupiedSpace());<br>            // Log.d(TAG, “Free Space: “ + currentFs.getFreeSpace());<br>            // Log.d(TAG, “Chunk size: “ + currentFs.getChunkSize());<br>            UsbFile root = currentFs.getRootDirectory();//获取根目录<br>            deviceName = currentFs.getVolumeLabel();//获取设备标签<br>            mMainTvTitle.setText(deviceName);//设置标题<br>            cFolder = root;//设置当前文件对象<br>            addFile2List();//添加文件<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>            setMsg(“读取失败，异常：” + e.getMessage());<br>        }<br>    }<br>    private void redDeviceList() {<br>        UsbManager usbManager = (UsbManager) getSystemService(Context.USB_SERVICE);<br>        //获取存储设备<br>        storageDevices = UsbMassStorageDevice.getMassStorageDevices(this);<br>        PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, new Intent(ACTION_USB_PERMISSION), 0);<br>        for (UsbMassStorageDevice device : storageDevices) {//可能有几个 一般只有一个 因为大部分手机只有1个otg插口<br>            if (usbManager.hasPermission(device.getUsbDevice())) {//有就直接读取设备是否有权限<br>                readDevice(device);<br>            } else {//没有就去发起意图申请<br>                usbManager.requestPermission(device.getUsbDevice(), pendingIntent); //该代码执行后，系统弹出一个对话框，<br>            }<br>        }<br>        if (storageDevices.length == 0)<br>            setMsg(“请插入U盘读取xxx”);<br>    }<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>当Android设备读取到U盘文件后，会显示出所有的文件夹及文件，因为我们只能对Excel文件进行操作处理，所以还要对用户选择的文件做判断处理</div></pre></td></tr></table></figure></p>
<p> @Override<br>    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {<br>    //点击item 进入该目录<br>        final UsbFile file = usbFiles.get(position);<br>        d(file.getName());<br>        if (file.isDirectory()) {//如果是文件夹<br>            cFolder = file;<br>            mMainTvTitle.append(“/“ + cFolder.getName());<br>            addFile2List();<br>        } else {<br>            if (file.getName().startsWith(“._”)) {<br>                toastShort(“请选择正确的Excel文件”);<br>                return;<br>            }<br>            if (file.getName().endsWith(“.xls”) || file.getName().endsWith(“.xlsx”)) {<br>                //设置视图<br>                dialog_wait.setMessage(“正在读取” + file.getName() + “…”);<br>                dialog_wait.show();<br>                //执行线程<br>                executorService.execute(new Runnable() {<br>                    @Override<br>                    public void run() {<br>                        try {<br>                            Looper.prepare();<br>                            ExcelUtils.readFromExcel(file, mHandler);<br>                            Looper.loop();<br>                        } catch (final Exception e) {<br>                            e.printStackTrace();<br>                            runOnUiThread(new Runnable() {<br>                                @Override<br>                                public void run() {<br>                                    dialog_wait.dismiss();<br>                                }<br>                            });<br>                        }<br>                    }<br>                });<br>            } else {<br>                toastShort(“请选择Excel文件进行操作”);<br>                return;<br>            }</p>
<pre><code>    }
}
</code></pre><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>接下来我们就需要对选择的Excel文件进行读取操作</div></pre></td></tr></table></figure>
<p>  public static void readFromExcel(final UsbFile fileAbsolutePath, final Handler handler) throws IOException {<br>        new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                /**</p>
<pre><code> * 读取Excel表中的所有数据
 */
Workbook workbook = null;
try {
    workbook = getWeebWork(fileAbsolutePath);
} catch (IOException e) {
    e.printStackTrace();
}
Logger.d(&quot;总表页数为：&quot; + workbook.getNumberOfSheets());// 获取表页数
Sheet sheet = workbook.getSheetAt(0);
int sheetNum = workbook.getNumberOfSheets();
int sheetRows = sheet.getLastRowNum();

Logger.d(&quot;the num of sheets is &quot; + sheetNum);
Logger.d(&quot;the name of sheet is  &quot; + sheet.getSheetName());
Logger.d(&quot;total rows is 行=&quot; + sheetRows);
// Sheet sheet = workbook.getSheetAt(1);
int rownum = sheet.getLastRowNum();// 获取总行数
Logger.d(rownum);
double sum = 0;
List&lt;SubsidyEntity&gt; subsidyEntities = new ArrayList&lt;SubsidyEntity&gt;();
for (int i = 1; i &lt;= rownum; i++) {//21
    Row row = sheet.getRow(i);
    int columns = row.getLastCellNum();// 总列数
    Logger.t(&quot;总列数&quot;).d(columns);
    for (int j = row.getFirstCellNum(); j &lt; row.getLastCellNum(); j++) {
        Cell celldata = row.getCell(j);
        Logger.t(&quot;getColumnIndex&quot;).d(celldata.getColumnIndex());
        Logger.t(&quot;cellData&quot;).d(celldata);
        SubsidyEntity subsidyEntity = new SubsidyEntity();
        switch (celldata.getColumnIndex()) {
            //证件号码
            case 0:
</code></pre><p>//                                subsidyEntity.setSubsidyIDNo(celldata.toString());<br>                                Logger.t(“证件号码”).d(celldata.toString());<br>                                break;<br>                            //用户姓名<br>                            case 1:<br>//                                subsidyEntity.setSubsidyName(celldata.toString());<br>                                Logger.t(“用户姓名”).d(celldata.toString());<br>                                break;<br>                            //补贴金额<br>                            case 2:<br>                                subsidyEntity.setSubsidyAmt(celldata.toString());<br>                                Logger.t(“补贴金额”).d(celldata.toString());<br>                                subsidyEntities.add(subsidyEntity);<br>                                break;<br>                            case 3:<br>                                break;<br>                        }<br>                    }<br>                }<br>                for (int j = 0; j &lt; subsidyEntities.size(); j++) {<br>                    Logger.d(subsidyEntities.size());<br>                    SubsidyEntity cellData = subsidyEntities.get(j);<br>                    Logger.d(cellData.getSubsidyAmt());<br>                    sum += Double.valueOf(String.valueOf(cellData.getSubsidyAmt()));<br>                    Logger.d(sum);<br>                }<br>                Message msg = Message.obtain();<br>                msg.arg1 = rownum;<br>                msg.arg2 = (int) sum;<br>                msg.what = Constants.MSG_GET_DATA_FROM_EXCEL_SUCCESS;<br>                handler.sendMessage(msg);<br>//                BigDecimal big = new BigDecimal(cellData.getNumericCellValue());//将科学计数法表示的数据转化为String类型<br>//                        Logger.d(“\t” + String.valueOf(big));<br>            }<br>        }).start();<br>    }<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* 当传入Excel文件名后需要对当前文件是Excel <span class="number">2003</span>还是Excel <span class="number">2007</span>进行处理</div></pre></td></tr></table></figure></p>
<p>/**</p>
<pre><code> * @param filename
 * @return
 * @throws IOException
 * @Title: getWeebWork
 * @Description: TODO(根据传入的文件名获取工作簿对象(Workbook))
 */
public static Workbook getWeebWork(UsbFile filename) throws IOException {
    Workbook workbook = null;
    if (null != filename) {
        String fileType = filename.getName().substring(filename.getName().lastIndexOf(&quot;.&quot;), filename.getName().length());
</code></pre><p>//            FileInputStream fileStream = new FileInputStream(new File(filename));<br>            if (“.xls”.equals(fileType.trim().toLowerCase())) {<br>//                workbook = new HSSFWorkbook(new UsbFileInputStream(filename));<br>                // or buffered (may increase performance)<br>//                workbook = new HSSFWorkbook(UsbFileStreamFactory.createBufferedOutputStream(filename, currentFs));<br>                // if you don’t have the current fs this should be fine as well<br>                workbook = new HSSFWorkbook(new BufferedInputStream(new UsbFileInputStream(filename)));<br>            } else if (“.xlsx”.equals(fileType.trim().toLowerCase())) {<br>                workbook = new XSSFWorkbook(new BufferedInputStream(new UsbFileInputStream(filename)));<br>            }<br>        }<br>        return workbook;<br>    }<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>通过Handler消息处理机制，将我们在子线程获取到的Excel文件在主线程进行处理</div></pre></td></tr></table></figure></p>
<p>   private class MyHandler extends Handler {<br>        //对Activity的弱引用<br>        private final WeakReference<subsidyreleaseactivity> mActivity;</subsidyreleaseactivity></p>
<pre><code>    public MyHandler(SubsidyReleaseActivity activity) {
        mActivity = new WeakReference&lt;SubsidyReleaseActivity&gt;(activity);
    }

    @Override
    public void handleMessage(Message msg) {
        SubsidyReleaseActivity activity = mActivity.get();
        if (activity == null) {
            super.handleMessage(msg);
            return;
        }
        switch (msg.what) {
            case Constants.MSG_GET_DATA_FROM_EXCEL_SUCCESS:
                subsidyTotalAmt = msg.arg2;//总行数
                subsidyTotalCount = msg.arg1;
                dialog_wait.dismiss();
                Logger.t(&quot;补助总笔数&quot;).d(subsidyTotalCount);
                Logger.t(&quot;补助总金额&quot;).d(subsidyTotalAmt);
                break;
        }
    }
}
</code></pre><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>最后我们在页面销毁时，注销广播，关闭USB设备</div></pre></td></tr></table></figure>
<p>   @Override<br>    protected void onDestroy() {<br>        super.onDestroy();<br>        if (mUsbReceiver != null) {//有注册就有注销<br>            unregisterReceiver(mUsbReceiver);<br>            mUsbReceiver = null;<br>        }<br>        if (sb != null) {<br>            sb.unsubscribe();<br>        }<br>        if (storageDevices != null) {<br>            for (UsbMassStorageDevice device : storageDevices) {<br>                device.close();<br>                storageDevices = null;<br>            }<br>        }<br>    }<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">## <span class="selector-tag">Android</span> 读取<span class="selector-tag">Assets</span> 下的<span class="selector-tag">Excel</span>文件</div><div class="line">&gt; 在我们做项目过程中，项目内测时，需要白名单控制，白名单实现的一种方案就是把用户的登录名电话号码作为白名单，如果不在白名单内则提示无法登录。此时，我们的白名单用户列表保存在<span class="selector-tag">Excel</span>文件中，我们可以把<span class="selector-tag">Excel</span>文件保存到<span class="selector-tag">Assets</span>下进行读取。</div><div class="line"></div><div class="line">* 首先需要把编辑好的<span class="selector-tag">Excel</span>文件放到<span class="selector-tag">main</span>目录下的<span class="selector-tag">assets</span>下。（如果位置放错则读取不到）</div><div class="line">  !<span class="selector-attr">[]</span>()&#123;<span class="attribute">http</span>://ome4apvpf.bkt.clouddn.com/WX20170610-<span class="number">141311</span>@<span class="number">2</span>x.png&#125;</div><div class="line"></div><div class="line">* 然后通过子线程来读取<span class="selector-tag">Excel</span>文件内容</div></pre></td></tr></table></figure></p>
<p> public static void getWhiteList(final Context context, final Handler handler) {<br>        new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                ArrayList<whitelistinfo> whitesList = new ArrayList<whitelistinfo>();<br>                AssetManager assetManager = context.getAssets();<br>                try {<br>                    InputStream fileStream = new BufferedInputStream(assetManager.open(“whitelist.xls”));<br>                    Workbook workbook = Workbook.getWorkbook(fileStream);<br>                    Sheet sheet = workbook.getSheet(0);<br>                    int sheetNum = workbook.getNumberOfSheets();<br>                    int sheetRows = sheet.getRows();<br>                    int sheetColumns = sheet.getColumns();<br>                    Log.d(TAG, “the num of sheets is “ + sheetNum);<br>                    Log.d(TAG, “the name of sheet is  “ + sheet.getName());<br>                    Log.d(TAG, “total rows is 行=” + sheetRows);<br>                    Log.d(TAG, “total cols is 列=” + sheetColumns);<br>                    for (int i = 0; i &lt; sheetRows; i++) {<br>                        WhiteListInfo whitesListPhone = new WhiteListInfo();<br>                        whitesListPhone.setPhoneNo(sheet.getCell(0, i).getContents());<br>                        whitesList.add(whitesListPhone);<br>                    }<br>                    workbook.close();<br>                } catch (Exception e) {<br>                    Log.e(TAG, “read error=” + e, e);<br>                }<br>                Message msg = Message.obtain();<br>                msg.obj = whitesList;<br>                msg.what = NetUrls.MSG_GET_WHITE_LIST_SUCC;<br>                // 发送这个消息到消息队列中<br>                handler.sendMessage(msg);</whitelistinfo></whitelistinfo></p>
<pre><code>        }
    }).start();
}
</code></pre><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>这里我们提前知道了Excel文件里面的内容，我这里只有一个电话号码列，所以要定义好相应的实体类 WhiteListInfo，将我们读取到的所以电话号码保存到List集合当中。</div><div class="line"></div><div class="line"><span class="bullet">* </span>在主线程获取到我们读取的内容</div></pre></td></tr></table></figure>
<p>  private void getWhiteListFromAsset() {<br>        handler = new Handler() {<br>            @Override<br>            public void handleMessage(Message msg) {<br>                super.handleMessage(msg);<br>                // 请求用户信息成功<br>                if (msg.what == NetUrls.MSG_GET_WHITE_LIST_SUCC) {<br>                    boolean isWhite = false;<br>                    whitesList = (ArrayList<whitelistinfo>) msg.obj;<br>                    for (WhiteListInfo whiteNo : whitesList) {<br>                        LogUtil.i(“白名单”, whiteNo.getPhoneNo());<br>                        if (whiteNo.getPhoneNo().equals(currentMobileNo)) {<br>                            isWhite = true;<br>                        }<br>                    }<br>                    dismissProgressDialog();<br>                    if (checkWhite &amp;&amp; !isWhite) {<br>                        new AlertDialog.Builder(MainActivity.this)<br>                                .setTitle(“提示”)<br>                                .setMessage(“您的账号未在测试白名单内！”)<br>                                .setPositiveButton(“确定”, new DialogInterface.OnClickListener() {<br>                                    @Override<br>                                    public void onClick(DialogInterface dialog, int which) {<br>                                        finish();<br>                                    }<br>                                })<br>                                .setCancelable(false)<br>                                .create()<br>                                .show();<br>                        return;<br>                    }<br>                    if (!isFirstRun) {<br>                        String preMobileNo = BankInfoUtils.getUserInfo(MainActivity.this).getMobileNo();<br>                        LogUtil.i(“bankInfo:”, currentMobileNo + “;” + preMobileNo);<br>                        if (!currentMobileNo.equals(preMobileNo)) {<br>                            Intent intent = new Intent(MainActivity.this, ChangeAccountActivity.class);<br>                            startActivity(intent);<br>                            finish();<br>                            return;<br>                        }<br>                    }<br>                    sharedPreferences.edit().putBoolean(“isFirstRun”, false).apply();<br>                    SharedPreferencesUtil.setPreferenceValue(MainActivity.this, “cipherText”, cipherText);<br>                    initUI();<br>                    initData();<br>                    initView();<br>                    initEvent();<br>                }<br>            }<br>        };<br>        HttpUtil.getWhiteList(this, handler);<br>    }<br>```</whitelistinfo></p>
<ul>
<li>注意事项：在读取Excel文件时有可能会遇到下面的错误<br><code>jxl.read.biff.BiffException: Unable to recognize OLE stream</code><br>这是因为因为文件是Excel2007，而jxl解析07会报上述异常，也就是jxl可以处理Excel2003。只需要原文件另存为2003文 件即可</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-读写-Excel-文件&quot;&gt;&lt;a href=&quot;#Android-读写-Excel-文件&quot; class=&quot;headerlink&quot; title=&quot;Android 读写 Excel 文件&quot;&gt;&lt;/a&gt;Android 读写 Excel 文件&lt;/h1&gt;&lt;bloc
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android自定义控件</title>
    <link href="http://www.liminwu.me/post/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6.html"/>
    <id>http://www.liminwu.me/post/Android自定义控件.html</id>
    <published>2017-04-11T05:59:15.000Z</published>
    <updated>2017-04-11T06:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h1><ul>
<li>Android自身带的控件不能满足需求, 需要根据自己的需求定义控件.</li>
</ul>
<h2 id="自定义控件可以分为三大类型"><a href="#自定义控件可以分为三大类型" class="headerlink" title="自定义控件可以分为三大类型"></a>自定义控件可以分为三大类型</h2><h3 id="1-组合已有的控件实现"><a href="#1-组合已有的控件实现" class="headerlink" title="1. 组合已有的控件实现"></a>1. 组合已有的控件实现</h3><ul>
<li><p>优酷菜单</p>
<pre><code>1. 在xml布局里摆放好, OK
2. 给指定控件添加点击事件. OK
3. 根据业务逻辑,执行动画(旋转动画: 补间动画). OK
4. 菜单按钮的截获. OK
</code></pre></li>
<li><p>轮播图广告</p>
<pre><code>1. 让图片滑动起来(ViewPager), OK
2. 让图片和文字,指示器对应起来, OK
3. 让轮播器无限循环

    向右无限循环  
        0 -&gt; 4    newPosition = position % 5  
        5 -&gt; 0  
        6 -&gt; 1  
        7 -&gt; 2  
        8 -&gt; 3  
        9 -&gt; 4  
       10 -&gt; 0  
    向左无限循环  
        设置到中间某个位置.        
4. 轮播器自动轮询, OK        
</code></pre></li>
<li><p>下拉选择框</p>
</li>
</ul>
<ul>
<li><p>Button或ImageButton等自带按钮功能的控件会抢夺所在Layout的焦点.导致其他区域点击不生效.在所在layout声明一个属性</p>
<pre><code>android:descendantFocusability=&quot;blocksDescendants&quot;
</code></pre></li>
<li><p>popupwindow获取焦点, 外部可点击</p>
<pre><code>    // 设置点击外部区域, 自动隐藏
popupWindow.setOutsideTouchable(true); // 外部可触摸
popupWindow.setBackgroundDrawable(new BitmapDrawable()); // 设置空的背景, 响应点击事件

popupWindow.setFocusable(true); //设置可获取焦点
</code></pre></li>
</ul>
<h3 id="2-完全自定义控件-继承View-ViewGroup"><a href="#2-完全自定义控件-继承View-ViewGroup" class="headerlink" title="2. 完全自定义控件.(继承View, ViewGroup)"></a>2. 完全自定义控件.(继承View, ViewGroup)</h3><ul>
<li><ol>
<li><p>自定义开关  </p>
<blockquote>
<ul>
<li><ol>
<li>写个类继承View, OK</li>
</ol>
</li>
<li><ol>
<li>拷贝包含包名的全路径到xml中, OK</li>
</ol>
</li>
<li><ol>
<li>界面中找到该控件, 设置初始信息, OK</li>
</ol>
</li>
<li><ol>
<li>根据需求绘制界面内容,OK</li>
</ol>
</li>
<li><ol>
<li>响应用户的触摸事件,OK</li>
</ol>
</li>
<li><ol>
<li>创建一个状态更新监听.OK</li>
</ol>
</li>
</ul>
</blockquote>
<p>// 1. 声明接口对象<br>public interface OnSwitchStateUpdateListener{<br>   // 状态回调, 把当前状态传出去<br>   void onStateUpdate(boolean state);<br>}<br>// 2. 添加设置接口对象的方法, 外部进行调用<br>public void setOnSwitchStateUpdateListener(</p>
<pre><code>OnSwitchStateUpdateListener onSwitchStateUpdateListener) {
    this.onSwitchStateUpdateListener = onSwitchStateUpdateListener;
</code></pre><p>}<br>// 3. 在合适的位置.执行接口的方法<br>onSwitchStateUpdateListener.onStateUpdate(state);</p>
<p>// 4. 界面/外部, 收到事件.</p>
<blockquote>
<ul>
<li><ol>
<li>自定义属性</li>
</ol>
</li>
</ul>
</blockquote>
<ol>
<li><p>在attrs.xml声明节点declare-styleable</p>
<p><declare-styleable name="ToggleView"></declare-styleable></p>
<pre><code>&lt;attr name=&quot;switch_background&quot; format=&quot;reference&quot; /&gt;
&lt;attr name=&quot;slide_button&quot; format=&quot;reference&quot; /&gt;
&lt;attr name=&quot;switch_state&quot; format=&quot;boolean&quot; /&gt;
</code></pre><p></p>
</li>
<li><p>R会自动创建变量</p>
<p>attr 3个变量<br>styleable 一个int数组, 3个变量(保存位置)</p>
</li>
<li><p>在xml配置声明的属性/ 注意添加命名空间</p>
<p>xmlns:itheima=”<a href="http://schemas.android.com/apk/res/com.itheima74.toggleview" target="_blank" rel="external">http://schemas.android.com/apk/res/com.itheima74.toggleview</a>“</p>
<p>itheima:switch_background=”@drawable/switch_background”<br>itheima:slide_button=”@drawable/slide_button”<br>itheima:switch_state=”false”</p>
</li>
<li><p>在构造函数中获取并使用</p>
<p>// 获取配置的自定义属性<br>String namespace = “<a href="http://schemas.android.com/apk/res/com.itheima74.toggleview" target="_blank" rel="external">http://schemas.android.com/apk/res/com.itheima74.toggleview</a>“;<br>int switchBackgroundResource = attrs.getAttributeResourceValue(namespace , “switch_background”, -1);</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<blockquote>
<ul>
<li>Android 的界面绘制流程</li>
</ul>
</blockquote>
<pre><code>测量             摆放        绘制
measure    -&gt;    layout    -&gt;    draw
      |           |             |
onMeasure -&gt; onLayout -&gt; onDraw 重写这些方法, 实现自定义控件

都在onResume()之后执行

View流程
onMeasure() (在这个方法里指定自己的宽高) -&gt; onDraw() (绘制自己的内容)

ViewGroup流程
onMeasure() (指定自己的宽高, 所有子View的宽高)-&gt; onLayout() (摆放所有子View) -&gt; onDraw() (绘制内容)
</code></pre><ul>
<li><ol>
<li>侧滑面板</li>
</ol>
</li>
</ul>
<h3 id="3-继承已有的控件实现-扩展已有的功能"><a href="#3-继承已有的控件实现-扩展已有的功能" class="headerlink" title="3. 继承已有的控件实现(扩展已有的功能)"></a>3. 继承已有的控件实现(扩展已有的功能)</h3><ul>
<li><ol>
<li>包含下拉刷新功能的ListView</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自定义控件&quot;&gt;&lt;a href=&quot;#自定义控件&quot; class=&quot;headerlink&quot; title=&quot;自定义控件&quot;&gt;&lt;/a&gt;自定义控件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Android自身带的控件不能满足需求, 需要根据自己的需求定义控件.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 i
    
    </summary>
    
    
      <category term="Android" scheme="http://www.liminwu.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 读写CSV文件</title>
    <link href="http://www.liminwu.me/post/Android%E8%AF%BB%E5%86%99CSV%E6%96%87%E4%BB%B6.html"/>
    <id>http://www.liminwu.me/post/Android读写CSV文件.html</id>
    <published>2017-04-10T06:20:21.000Z</published>
    <updated>2017-04-11T01:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景："><a href="#需求背景：" class="headerlink" title="需求背景："></a>需求背景：</h2><p>   最近在做项目过程中，有以下需求：将用户的交易数据写入到本地文件中，并保存为.csv文件格式，以便导出时供用户查看。</p>
<h2 id="何为-csv文件？"><a href="#何为-csv文件？" class="headerlink" title="何为.csv文件？"></a>何为.csv文件？</h2><p>   csv文件是以逗号分割的数据仓储，读取数据时从每一行中读取一条数据元祖，也就是一条数据，再用字符分割的方式获取表中的每一个数据项。</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>   首先来简单说下 Android 的文件读写。说到文件的存储，就要涉及到内部存储（internal storage）和外部存储（external storage）。</p>
<h3 id="内部存储："><a href="#内部存储：" class="headerlink" title="内部存储："></a>内部存储：</h3><p>   注意内部存储不是内存。内部存储位于系统中很特殊的一个位置，如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。<strong>当一个应用卸载之后，内部存储中的这些文件也被删除</strong>。从技术上来讲如果你在创建内部存储文件的时候将文件属性设置成可读，其他app能够访问自己应用的数据，前提是他知道你这个应用的包名，如果一个文件的属性是私有（private），那么即使知道包名其他应用也无法访问。 内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。Shared Preferences和SQLite数据库都是存储在内部存储空间上的。内部存储一般用Context来获取和操作。<br>   getFilesDir()获取app的内部存储空间，相当于应用在内部存储上的根目录。<br>   如果是要创建一个文件，如下：<br>   <img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-150933@2x.png" alt="img"><br>   Android 为我们提供了一个简便方法’openFileOutput()’来读写应用在内部存储空间上的文件，下面是向文件中写入文件的例子：<br>   <img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-152021@2x.png" alt="img"><br>   总结一下文件相关操作，可以得出以下三个特点：</p>
<ul>
<li>1 文件操作只需要向函数提供文件名，所以程序自己只需要维护文件名即可。</li>
<li>2 不用自己去创建文件对象和输入、输出流，提供文件名就可以返回File对象或输入输出流。</li>
<li><p>3 对于路径操作返回的都是文件对象。</p>
<h3 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h3><p>最容易混淆的是外部存储，如果说 PC 上也要区分出外部存储和内部存储的话，那么自带的硬盘算是内部存储，U盘或者移动硬盘算是外部存储，因此我们很容易带着这样的理解去看待安卓手机，认为机身固有存储是内部存储，而扩展的 T 卡是外部存储。比如我们任务 16GB 版本的 Nexus 4有 16G 的内部存储，普通消费者可以这样理解，但是安卓的编程中不能，这 16GB 仍然是外部存储。</p>
<p>所有的安卓设备都有外部存储和内部存储，这两个名称来源于安卓的早期设备，那个时候的设备内部存储确实是固定的，而外部存储确实是可以像U盘一样移动的。但是在后来的设备中，很多中高端机器都将自己的机身存储扩展到了 8G 以上，他们将存储在概念上分成了”内部internal” 和”外部external” 两部分，但其实都在手机内部。所以不管安卓手机是否有可移动的sdcard，他们总是有外部存储和内部存储。最关键的是，我们都是通过相同的api来访问可移动的sdcard或者手机自带的存储（外部存储）。</p>
<p>外部存储中的文件是可以被用户或者其他应用程序修改的，有两种类型的文件（或者目录）：</p>
</li>
<li><p>公共文件Public files：文件是可以被自由访问，且文件的数据对其他应用或者用户来说都是由意义的，当应用被卸载之后，其卸载前创建的文件仍然保留。比如camera应用，生成的照片大家都能访问，而且camera不在了，照片仍然在。<br>如果想在外存储上放公共文件你可以使用getExternalStoragePublicDirectory()</p>
</li>
<li><p>私有文件Private files：其实由于是外部存储的原因即是是这种类型的文件也能被其他程序访问，只不过一个应用私有的文件对其他应用其实是没有访问价值的（恶意程序除外）。外部存储上，应用私有文件的价值在于卸载之后，这些文件也会被删除。类似于内部存储。<br>创建应用私有文件的方法是Context.getExternalFilesDir()。所有应用程序的外部存储的私有文件都放在根目录的Android/data/下，目录形式为/Android/data/<package_name>/</package_name></p>
<h3 id="getFilesDir，getExternalFilesDir，getExternalStorageDirectory-，getExternalStoragePublicDirectory"><a href="#getFilesDir，getExternalFilesDir，getExternalStorageDirectory-，getExternalStoragePublicDirectory" class="headerlink" title="getFilesDir，getExternalFilesDir，getExternalStorageDirectory ，getExternalStoragePublicDirectory"></a>getFilesDir，getExternalFilesDir，getExternalStorageDirectory ，getExternalStoragePublicDirectory</h3><p>最后为了弄清楚getFilesDir，getExternalFilesDir，getExternalStorageDirectory，getExternalStoragePublicDirectory等android文件操作方法，我将这些方法的执行结果打印出来，看看到底路径是啥样，在activity中执行以下代码：<br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-154228@2x.png" alt="img"><br>在log中看到如下结果：<br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-154018@2x.png" alt="img"><br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-154120@2x.png" alt="img"><br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-154054@2x.png" alt="img"><br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-154149@2x.png" alt="img"></p>
<h2 id="csv-文件的读写"><a href="#csv-文件的读写" class="headerlink" title=".csv 文件的读写"></a>.csv 文件的读写</h2><ul>
<li>1 将.csv文件写入到内存<br>项目需求是在进行充值交易时，为了看到交易前与交易后数据是否成功，所以在交易前先将一些可知的请求参数写入文件当中，首先在主 Activity 中编写以下代码:<br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-155640@2x.png" alt="img"><br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-155824@2x.png" alt="img"><br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-155848@2x.png" alt="img"><br>然后将表头数据写入’buffer.append(“交易批次,交易序号,客户名,身份证号,卡号,交易流水,交易原金额,交易金额,交易后金额,交易时间,交易是否成功,是否超时\r\n”);’<br>等交易成功后，再将请求响应获得的数据，追加到上面写入的文件末尾，代码如下：<br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-160543@2x.png" alt="img"><br>至此，我们已经将.csv格式的文件写入到本地，预览效果如下：<br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-161154@2x.png" alt="img"></li>
<li>2 读完.csv文件显示到界面上<br>用户在APP交易明细查询中需要显示出文件中保存的数据，所以我们还需要将保存到.csv文件中的内容显示到界面上。代码如下:<br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-161555@2x.png" alt="img"><br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-161618@2x.png" alt="img"><br>在读取.csv格式的文件中，用到了第三方解析工具javacsv.jar，可以在网上自行搜索下载到，<br>工具类代码如下:<br><img src="http://ome4apvpf.bkt.clouddn.com/WX20170410-162148@2x.png" alt="img"></li>
</ul>
<p>参考:「android中的文件操作详解以及内部存储和外部存储」<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0923/1557.html" target="_blank" rel="external">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0923/1557.html</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求背景：&quot;&gt;&lt;a href=&quot;#需求背景：&quot; class=&quot;headerlink&quot; title=&quot;需求背景：&quot;&gt;&lt;/a&gt;需求背景：&lt;/h2&gt;&lt;p&gt;   最近在做项目过程中，有以下需求：将用户的交易数据写入到本地文件中，并保存为.csv文件格式，以便导出时供用户查
    
    </summary>
    
    
      <category term="Android" scheme="http://www.liminwu.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装Homebrew</title>
    <link href="http://www.liminwu.me/post/Mac%E5%AE%89%E8%A3%85Homebrew.html"/>
    <id>http://www.liminwu.me/post/Mac安装Homebrew.html</id>
    <published>2017-03-12T16:23:57.000Z</published>
    <updated>2017-04-10T06:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac安装Homebrew"><a href="#Mac安装Homebrew" class="headerlink" title="Mac安装Homebrew"></a>Mac安装Homebrew</h1><p>brew 全称Homebrew  是Mac OSX上的软件包管理工具<br>Homebrew 安装和卸载工具 只用一行命令就能完成<br>官方地址:    <a href="http://brew.sh/index.html" target="_blank" rel="external">http://brew.sh/index.html</a><br>mac 自带ruby<br>打开命令行  terminal<br>输入  :</p>
<ol>
<li>ruby -version<br>命令行输出:<br><img src="http://ome4apvpf.bkt.clouddn.com/17-3-13/32933292-file_1489336308768_426.png" alt="img"><h3 id="1-安装命令"><a href="#1-安装命令" class="headerlink" title="1) 安装命令"></a>1) 安装命令</h3></li>
<li>ruby -e “$(curl -fsSL <a href="https://raw.github.com/Homebrew/homebrew/go/install" target="_blank" rel="external">https://raw.github.com/Homebrew/homebrew/go/install</a>)”<br>假如已经安装了  输入如下命令</li>
<li>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”<br>命令行输出:<br><img src="http://ome4apvpf.bkt.clouddn.com/17-3-13/3446560-file_1489336480805_10e6d.png" alt="img"><h3 id="2-brew-使用方法"><a href="#2-brew-使用方法" class="headerlink" title="2) brew 使用方法"></a>2) brew 使用方法</h3>命令行 输入:  brew<br>输出:<br><img src="http://ome4apvpf.bkt.clouddn.com/17-3-13/15237410-file_1489336625045_2046.png" alt="img"><h3 id="3-安装工具"><a href="#3-安装工具" class="headerlink" title="3) 安装工具"></a>3) 安装工具</h3>举个栗子:   Mongodb  这个工具<br>输入命令:   brew install Mongodb<br>如图:<br><img src="http://ome4apvpf.bkt.clouddn.com/17-3-13/8164777-file_1489336698870_11cd.png" alt="img"><h3 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4)  卸载"></a>4)  卸载</h3>拿上面的栗子:   Mongodb 工具<br>输入命令    brew uninstall Mongodb<h3 id="5-工具安装的目录"><a href="#5-工具安装的目录" class="headerlink" title="5)  工具安装的目录"></a>5)  工具安装的目录</h3>Homebrew 会将套件安装到独立目录，并将文件软链接至/usr/local 。</li>
<li>$ cd /usr/local  </li>
<li>$ find Cellar  </li>
<li>Cellar/wget/1.16.1  </li>
<li>Cellar/wget/1.16.1/bin/wget  </li>
<li>Cellar/wget/1.16.1/share/man/man1/wget.1  </li>
<li>$ ls -l bin  </li>
<li>bin/wget -&gt; ../Cellar/wget/1.16.1/bin/wget<br>Homebrew 的所有文件均会被安装到预定义目录下，所以无需担心 Homebrew 的安装位置。<h3 id="6-其他命令"><a href="#6-其他命令" class="headerlink" title="6) 其他命令"></a>6) 其他命令</h3>brew list       列出已安装的软件<br>brew update     更新brew<br>brew home       用浏览器打开brew的官方网站<br>brew info       显示软件信息<br>brew deps        显示包依赖<br>更多命令请看:    <a href="https://git.io/brew-docs" target="_blank" rel="external">https://git.io/brew-docs</a><h3 id="7-安装过程中遇到的问题"><a href="#7-安装过程中遇到的问题" class="headerlink" title="7)安装过程中遇到的问题"></a>7)安装过程中遇到的问题</h3>brew安装应用的时候碰上“curl: (7) couldn’t connect to host 的问题”,可以使用代理，让curl通过代理来访问。编辑$HOME/.curlrc文件，增加“–socks5 127.0.0.1:1080”即可（替换成你自己的代理），这样你在brew install安装的时候，相应curl就会通过socks代理访问，从而成功下载完成安装。方便简单，就是你需要自己设置一个socks代理。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac安装Homebrew&quot;&gt;&lt;a href=&quot;#Mac安装Homebrew&quot; class=&quot;headerlink&quot; title=&quot;Mac安装Homebrew&quot;&gt;&lt;/a&gt;Mac安装Homebrew&lt;/h1&gt;&lt;p&gt;brew 全称Homebrew  是Mac OSX上
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.liminwu.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.liminwu.me/post/hello-world.html"/>
    <id>http://www.liminwu.me/post/hello-world.html</id>
    <published>2017-01-17T07:08:53.000Z</published>
    <updated>2017-01-17T07:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
